<!DOCTYPE html>
<html>

<head>
    <title>AI绘画 - 文本生成图像</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        :root {
            --primary-color: #7952b3;
            --primary-color-hover: #61408c;
            --primary-color-light: rgba(121, 82, 179, 0.1);
            --primary-rgb: 121, 82, 179;

            --text-color: #212529;
            --text-muted: #6c757d;
            --text-light: #f8f9fa;
            --border-color: #ced4da;
            --input-bg: #fff;
            --bg-light: #f8f9fa;
            --bg-body: #f0f2f5;
            --danger-color: #dc3545;
            --danger-bg: #f8d7da;
            --danger-border: #f5c6cb;


            --border-radius-sm: 4px;
            --border-radius-md: 6px;
            --border-radius-lg: 8px;

            --input-bar-height: 110px;
            --input-bar-height-mobile: 150px;
        }

        ::-webkit-scrollbar {
            width: 6px;
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: #bbb;
            border-radius: var(--border-radius-md);
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #999;
        }

        html {
            scrollbar-width: thin;
            scrollbar-color: #bbb transparent;
            -ms-overflow-style: none;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--bg-body);
            color: var(--text-color);
            line-height: 1.6;
            min-height: 100vh;
            box-sizing: border-box;
            padding-top: 25px;
            padding-bottom: var(--input-bar-height);
            transition: padding-bottom 0.3s ease-out;
            overflow-x: hidden;
        }

        #input-container {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: var(--input-bg);
            padding: 15px 20px;
            box-shadow: 0 -3px 15px rgba(0, 0, 0, 0.08);
            border-top: 1px solid #e0e0e0;
            z-index: 999;
            display: flex;
            flex-direction: column;
            gap: 10px;
            box-sizing: border-box;
        }

        .input-row {
            display: flex;
            align-items: center;
            gap: 15px;
            width: 100%;
        }
        .input-row-1 {
            gap: 10px;
            align-items: stretch;
        }

        #prompt-input {
            flex-grow: 1;
            padding: 12px 15px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-md);
            font-size: 1em;
            background-color: var(--input-bg);
            transition: border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
        }
        #prompt-input:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 0.2rem var(--primary-color-light);
            outline: 0;
        }

        #send-button {
            padding: 12px 28px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: var(--border-radius-md);
            cursor: pointer;
            font-size: 1em;
            font-weight: 500;
            transition: background-color 0.2s ease;
            flex-shrink: 0;
        }
        #send-button:hover {
            background-color: var(--primary-color-hover);
        }
        #send-button:disabled {
            background-color: #adb5bd;
            color: var(--text-muted);
            cursor: not-allowed;
        }

        .input-row-2 {
            flex-wrap: wrap;
            align-items: flex-end;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            flex: 1 1 auto;
            min-width: 120px;
        }
        .control-group label,
        .enhance-label {
            font-size: 0.85em;
            color: var(--text-muted);
            font-weight: 500;
        }
        .control-group select,
        #custom-width-input, #custom-height-input {
            padding: 10px 12px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-md);
            font-size: 0.9em;
            background-color: var(--input-bg);
            width: 100%;
            box-sizing: border-box;
            transition: border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
        }
        .control-group select:focus,
        #custom-width-input:focus, #custom-height-input:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 0.2rem var(--primary-color-light);
            outline: 0;
        }

        #custom-dimensions-wrapper {
            width: 100%;
            padding-top: 5px;
        }
        .input-row-custom-dims {
            display: flex;
            gap: 15px;
            width: 100%;
        }
        .input-row-custom-dims .control-group {
            flex: 1;
        }


        .enhance-group {
            display: flex;
            align-items: center;
            gap: 8px;
            padding-top: 22px;
            flex-shrink: 0;
        }
        #enhance-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: var(--primary-color);
        }

        #image-display-area {
            width: 100%;
            max-width: 100%;
            margin: 0 auto;
            padding: 0 10px;
            box-sizing: border-box;
            height: calc(100vh - var(--input-bar-height) - 70px);
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            perspective: 1200px;
            perspective-origin: 50% 40%;
            overflow: hidden;
        }
        .placeholder-text {
            color: #999;
            font-style: italic;
            text-align: center;
            padding: 25px;
            width: 100%;
            font-size: 0.95em;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .image-container {
            position: absolute;
            border-radius: var(--border-radius-lg);
            overflow: hidden;
            cursor: pointer;
            background-color: #e9ecef;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.15);
            will-change: transform, opacity, width, height, z-index;
            backface-visibility: hidden;
        }

        .image-container img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            display: block;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
        }
        .image-container img.loaded {
            opacity: 1;
            cursor: pointer;
        }
        .image-container img.error-state {
            display: none;
        }
        .image-label {
            position: absolute;
            bottom: 8px;
            left: 8px;
            background: rgba(0, 0, 0, 0.65);
            color: var(--text-light);
            padding: 3px 7px;
            border-radius: var(--border-radius-sm);
            font-size: 10px;
            opacity: 0;
            transition: opacity 0.2s ease;
            z-index: 3;
            pointer-events: none;
        }
        .image-container.is-front .image-label {
            opacity: 1;
        }

        .loader {
            border: 4px solid #e0e0e0;
            border-top: 4px solid var(--primary-color);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            z-index: 2;
            display: block;
            margin-bottom: 5px;
        }
        .loader.hidden { display: none; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(30, 30, 30, 0.92);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        .modal.active { display: flex; }
        .modal-content {
            position: relative;
            max-width: 90%;
            max-height: 90vh;
        }
        .modal-content img {
            display: block;
            max-width: 100%;
            max-height: 90vh;
            object-fit: contain;
            border-radius: var(--border-radius-sm);
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
        }
        .modal-close {
            position: absolute;
            top: 15px;
            right: 20px;
            color: #ccc;
            font-size: 40px;
            cursor: pointer;
            z-index: 1001;
            line-height: 1;
            transition: color 0.2s ease;
        }
        .modal-close:hover { color: white; }
        .modal-nav {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            color: #ccc;
            font-size: 48px;
            cursor: pointer;
            padding: 15px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.3s, color 0.3s;
            z-index: 1002;
            user-select: none;
            width: 30px;
            height: 30px;
            line-height: 30px;
        }
        .modal-nav:hover {
            background: rgba(0, 0, 0, 0.5);
            color: white;
        }
        .modal-prev { left: 20px; }
        .modal-next { right: 20px; }

        .error-display {
            color: var(--danger-color);
            background-color: var(--danger-bg);
            border: 1px solid var(--danger-border);
            padding: 10px 15px;
            border-radius: var(--border-radius-md);
            font-size: 0.9em;
            text-align: center;
            max-width: 85%;
            word-wrap: break-word;
            z-index: 2;
            margin-top: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        .retry-button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: var(--border-radius-md);
            cursor: pointer;
            font-size: 0.88em;
            margin-top: 10px;
            transition: background-color 0.2s;
            z-index: 2;
            font-weight: 500;
        }
        .retry-button:hover { background-color: var(--primary-color-hover); }
        .retry-button:disabled { background-color: #cccccc; cursor: not-allowed; }

        #custom-context-menu {
            position: absolute;
            display: none;
            background-color: var(--input-bg);
            border: 1px solid #ddd;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            border-radius: var(--border-radius-md);
            padding: 6px 0;
            z-index: 1001;
            min-width: 160px;
        }
        .context-menu-item {
            padding: 10px 18px;
            cursor: pointer;
            font-size: 0.9em;
            color: var(--text-color);
            transition: background-color 0.15s ease;
        }
        .context-menu-item:hover {
            background-color: var(--bg-light);
            color: var(--primary-color);
        }

        @media (max-width: 768px) {
            body { padding-bottom: var(--input-bar-height-mobile); }
            #input-container { gap: 12px; }
            .input-row-2 { gap: 12px; }
            .control-group { min-width: 100px; }
            .enhance-group { padding-top: 5px; justify-content: flex-start; }
            #image-display-area {
                perspective-origin: 50% 45%;
            }
        }

        @media (max-width: 480px) {
            .input-row-1 { flex-wrap: wrap; }
            .input-row-1 #prompt-input { flex-basis: 100%; margin-bottom: 10px; }
            .input-row-1 #send-button { flex-basis: 100%; padding: 12px; }

            .input-row-2 { flex-direction: column; align-items: stretch; gap: 10px; }
            .input-row-2 .control-group { width: 100%; min-width: unset; }
            .input-row-2 .enhance-group {
                width: 100%;
                padding-top: 10px;
                justify-content: center;
            }
            .input-row-custom-dims { flex-direction: column; gap: 10px;}
            #image-display-area {
                perspective-origin: 50% 50%;
                height: calc(100vh - var(--input-bar-height-mobile) - 60px);
            }
        }
    </style>
</head>

<body>

    <div id="image-display-area">
        <div class="placeholder-text">
            在下方输入提示词，选择您的选项，然后点击"发送"生成图像。
            <br>图像将显示在此处。右键点击最前方的图像可查看选项。
        </div>
    </div>

    <div class="modal">
        <span class="modal-close">×</span>
        <div class="modal-nav modal-prev">❮</div>
        <div class="modal-nav modal-next">❯</div>
        <div class="modal-content">
            <img src="" alt="预览">
        </div>
    </div>

    <div id="input-container">
        <div class="input-row input-row-1">
            <input type="text" id="prompt-input" placeholder="输入您的图像提示词...">
            <button id="send-button">发送</button>
        </div>
        <div class="input-row input-row-2">
            <div class="control-group">
                <label for="model-select">模型:</label>
                <select id="model-select">
                    <option value="flux" selected>Flux</option>
                    <option value="turbo">Turbo</option>
                </select>
            </div>
            <div class="control-group">
                <label for="dimension-select">尺寸:</label>
                <select id="dimension-select">
                    <option value="512x512">方形 (512x512 - 经典SD)</option>
                    <option value="768x768">方形 (768x768 - 标准SD)</option>
                    <option value="1024x1024">方形 (1024x1024 - 通用)</option>
                    <option value="512x768">竖向 (512x768 - 2:3)</option>
                    <option value="768x1024">竖向 (768x1024 - 3:4)</option>
                    <option value="720x1280">竖向 (720x1280 - 9:16)</option>
                    <option value="832x1216" selected>竖向 (832x1216 肖像)</option>
                    <option value="768x512">横向 (768x512 - 3:2)</option>
                    <option value="1024x768">横向 (1024x768 - 4:3)</option>
                    <option value="1280x720">横向 (1280x720 - 16:9)</option>
                    <option value="1216x832">横向 (1216x832 - 风景)</option>
                    <option value="custom">自定义...</option>
                </select>
            </div>
            <div class="enhance-group">
                <input type="checkbox" id="enhance-checkbox" checked>
                <label for="enhance-checkbox" class="enhance-label">增强效果</label>
            </div>
        </div>
        <div id="custom-dimensions-wrapper" style="display: none;">
             <div class="input-row input-row-custom-dims">
                <div class="control-group">
                    <label for="custom-width-input">宽度 (64-2048, 8的倍数):</label>
                    <input type="number" id="custom-width-input" min="64" max="2048" step="8" placeholder="512">
                </div>
                <div class="control-group">
                    <label for="custom-height-input">高度 (64-2048, 8的倍数):</label>
                    <input type="number" id="custom-height-input" min="64" max="2048" step="8" placeholder="768">
                </div>
            </div>
        </div>
    </div>

    <div id="custom-context-menu">
        <div class="context-menu-item" data-action="copy">复制图像</div>
        <div class="context-menu-item" data-action="download">下载图像</div>
    </div>

    <script>
        const imageDisplayArea = document.getElementById('image-display-area');
        const placeholderText = imageDisplayArea.querySelector('.placeholder-text');
        const promptInput = document.getElementById('prompt-input');
        const modelSelect = document.getElementById('model-select');
        const dimensionSelect = document.getElementById('dimension-select');
        const enhanceCheckbox = document.getElementById('enhance-checkbox');
        const sendButton = document.getElementById('send-button');
        const modal = document.querySelector('.modal');
        const modalImg = modal.querySelector('img');
        const closeBtn = modal.querySelector('.modal-close');
        const prevBtn = modal.querySelector('.modal-prev');
        const nextBtn = modal.querySelector('.modal-next');
        const contextMenu = document.getElementById('custom-context-menu');
        const customDimensionsWrapper = document.getElementById('custom-dimensions-wrapper');
        const customWidthInput = document.getElementById('custom-width-input');
        const customHeightInput = document.getElementById('custom-height-input');

        let currentModalIndex = 0;
        let imagesData = [];
        let currentPrompt = '';
        const NOLOGO = true;
        const NUM_IMAGES = 3;

        let cardElements = [];
        let currentCardOrder = Array.from({ length: NUM_IMAGES }, (_, i) => i);
        let isAnimating = false;


        function adjustBodyPadding() {
            const inputContainer = document.getElementById('input-container');
            if (!inputContainer) return;
            inputContainer.style.visibility = 'hidden';
            inputContainer.style.position = 'absolute';
            const inputContainerHeight = inputContainer.offsetHeight;
            inputContainer.style.visibility = 'visible';
            inputContainer.style.position = 'fixed';
            document.body.style.paddingBottom = `${inputContainerHeight}px`;
            if (imagesData.length > 0 && cardElements.length > 0) {
                updateCardStackView(true);
            }
        }

        function findOrUpdateImageData(index, data) {
            const existingIndex = imagesData.findIndex(item => item.index === index);
            const fullData = { index, ...data };
            if (existingIndex > -1) {
                imagesData[existingIndex] = { ...imagesData[existingIndex], ...fullData };
            } else {
                imagesData.push(fullData);
                imagesData.sort((a, b) => a.index - b.index);
            }
            return imagesData.find(item => item.index === index);
        }

        function getSelectedDimensions() {
            const selectedValue = dimensionSelect.value;
            if (selectedValue === 'custom') {
                const width = parseInt(customWidthInput.value, 10);
                const height = parseInt(customHeightInput.value, 10);
                if (isNaN(width) || isNaN(height) || width < 64 || width > 2048 || height < 64 || height > 2048 || width % 8 !== 0 || height % 8 !== 0) {
                    alert("自定义尺寸无效。宽度和高度必须是64到2048之间且为8的倍数的数字。");
                    if (isNaN(width) || width < 64 || width > 2048 || width % 8 !== 0) customWidthInput.focus();
                    else if (isNaN(height) || height < 64 || height > 2048 || height % 8 !== 0) customHeightInput.focus();
                    return { error: true };
                }
                return { width, height };
            } else {
                const parts = selectedValue.split('x');
                return { width: parseInt(parts[0], 10), height: parseInt(parts[1], 10) };
            }
        }

        function initializeCardElements() {
            imageDisplayArea.innerHTML = '';
            imageDisplayArea.appendChild(placeholderText);
            placeholderText.style.display = 'block';

            cardElements = [];
            for (let i = 0; i < NUM_IMAGES; i++) {
                const container = document.createElement('div');
                container.className = 'image-container';
                container.style.display = 'none';
                container.dataset.cardSlotIndex = i;

                const img = document.createElement('img');
                img.alt = "AI Generated Image";

                const loader = document.createElement('div');
                loader.className = 'loader hidden';

                const label = document.createElement('div');
                label.className = 'image-label';

                container.appendChild(img);
                container.appendChild(loader);
                container.appendChild(label);
                imageDisplayArea.appendChild(container);
                cardElements.push(container);

                img.onload = () => handleImageLoad(img);
                img.onerror = () => handleImageError(img);

                container.addEventListener('click', function(event) {
                    if (isAnimating) return;

                    const clickedVisualSlotIndex = parseInt(this.dataset.cardSlotIndex, 10);

                    const imageDataOriginalIndexStr = this.dataset.imageDataOriginalIndex;

                    if (imageDataOriginalIndexStr === undefined) return;

                    const imageDataOriginalIndex = parseInt(imageDataOriginalIndexStr, 10);
                    if (isNaN(imageDataOriginalIndex) || !imagesData.find(d => d.index === imageDataOriginalIndex)) return;

                    if (event.target.closest('.retry-button')) return;

                    const currentImageData = imagesData.find(d => d.index === imageDataOriginalIndex);
                    if (!currentImageData) return;

                    if (clickedVisualSlotIndex === 0) {
                        if (currentImageData.error !== true) {
                            showImage(imageDataOriginalIndex);
                        }
                    } else {
                        let newOrder;
                        if (clickedVisualSlotIndex === 1) {
                            newOrder = [currentCardOrder[1], currentCardOrder[2], currentCardOrder[0]];
                            animateCardRotation(newOrder);
                        } else if (clickedVisualSlotIndex === 2) {
                            newOrder = [currentCardOrder[2], currentCardOrder[0], currentCardOrder[1]];
                            animateCardRotation(newOrder);
                        }
                    }
                });
            }
        }

        function updateCardStackView(useDefaultTransitions = true) {
            if (imagesData.length === 0 || cardElements.length === 0) {
                placeholderText.style.display = 'block';
                cardElements.forEach(card => card.style.display = 'none');
                return;
            }
            placeholderText.style.display = 'none';

            const areaWidth = imageDisplayArea.clientWidth;
            const areaHeight = imageDisplayArea.clientHeight;

            const frontImageOriginalIndex = currentCardOrder[0];
            const frontImageData = imagesData.find(img => img.index === frontImageOriginalIndex);
            const aspectRatio = (frontImageData && frontImageData.width && frontImageData.height) ?
                                (frontImageData.width / frontImageData.height) : (3/4);

            let frontCardWidth, frontCardHeight;

            // Calculate target dimensions to fill the area more, maintaining aspect ratio
            const areaAspectRatio = areaWidth / areaHeight;

            if (aspectRatio > areaAspectRatio) { // Image is wider relative to area
                frontCardWidth = areaWidth * 0.9; // Use a larger percentage of area width
                frontCardHeight = frontCardWidth / aspectRatio;
                if (frontCardHeight > areaHeight * 0.9) { // Ensure it doesn't exceed area height significantly
                     frontCardHeight = areaHeight * 0.9;
                     frontCardWidth = frontCardHeight * aspectRatio;
                }
            } else { // Image is taller relative to area
                frontCardHeight = areaHeight * 0.9; // Use a larger percentage of area height
                frontCardWidth = frontCardHeight * aspectRatio;
                if (frontCardWidth > areaWidth * 0.9) { // Ensure it doesn't exceed area width significantly
                    frontCardWidth = areaWidth * 0.9;
                    frontCardHeight = frontCardWidth / aspectRatio;
                }
            }

            // Ensure minimum size if needed, but primarily aim to fill
             frontCardWidth = Math.max(150, frontCardWidth);
             frontCardHeight = Math.max(150 / aspectRatio, frontCardHeight); // Maintain aspect ratio for minimum

            const backCardScale = 0.85; // Slightly larger scale for side cards
            const backCardWidth = frontCardWidth * backCardScale;
            const backCardHeight = frontCardHeight * backCardScale;
            const backCardOpacity = 0.9;

            const xOffset = frontCardWidth * 0.40; // Reduced X offset
            const zOffset = -Math.min(areaWidth * 0.08, frontCardWidth * 0.15); // Reduced Z offset
            const rotationAngle = 30; // Reduced rotation angle

            const positions = [
                { transform: `translate3d(0, 0, ${areaWidth * 0.05}px) scale(1) translateZ(0)`, zIndex: 3, opacity: 1, width: frontCardWidth, height: frontCardHeight, isFront: true },
                { transform: `translate3d(-${xOffset}px, 0, ${zOffset}px) rotateY(${rotationAngle}deg) scale(${backCardScale}) translateZ(0)`, zIndex: 2, opacity: backCardOpacity, width: backCardWidth,  height: backCardHeight, isFront: false },
                { transform: `translate3d(${xOffset}px, 0, ${zOffset}px) rotateY(-${rotationAngle}deg) scale(${backCardScale}) translateZ(0)`, zIndex: 1, opacity: backCardOpacity, width: backCardWidth,  height: backCardHeight, isFront: false }
            ];

            for (let visualSlotIdx = 0; visualSlotIdx < NUM_IMAGES; visualSlotIdx++) {
                const cardElement = cardElements.find(el => parseInt(el.dataset.cardSlotIndex, 10) === visualSlotIdx);

                if (!cardElement) {
                    continue;
                }

                if (!useDefaultTransitions) {
                    cardElement.style.transition = 'none';
                } else {
                     if (cardElement.style.transition === 'none') {
                         cardElement.style.transition = '';
                    }
                }

                const imageDataOriginalIndex = currentCardOrder[visualSlotIdx];
                const imgData = imagesData.find(d => d.index === imageDataOriginalIndex);
                const posStyle = positions[visualSlotIdx];

                cardElement.style.width = `${posStyle.width}px`;
                cardElement.style.height = `${posStyle.height}px`;
                cardElement.style.transform = posStyle.transform;
                cardElement.style.zIndex = posStyle.zIndex;
                cardElement.style.opacity = posStyle.opacity;
                cardElement.classList.toggle('is-front', posStyle.isFront);
                cardElement.dataset.imageDataOriginalIndex = imageDataOriginalIndex;

                const imgTag = cardElement.querySelector('img');
                const loader = cardElement.querySelector('.loader');
                const label = cardElement.querySelector('.image-label');

                cardElement.querySelectorAll('.error-display, .retry-button').forEach(el => el.remove());

                if (imgData) {
                    cardElement.style.display = 'flex';
                    imgTag.dataset.index = imgData.index;

                    if (imgTag.src !== imgData.src || imgData.error === null || !imgTag.getAttribute('src')) {
                        imgTag.src = '';
                        imgTag.classList.remove('loaded', 'error-state');
                        loader.classList.remove('hidden');
                        imgTag.src = imgData.src;
                    }

                    imgTag.alt = `AI Image ${imgData.index + 1} - ${imgData.prompt}`;
                    label.textContent = `Seed: ${imgData.seed}`;

                    if (imgData.error) {
                        handleImageError(imgTag);
                    } else if (imgTag.complete && imgTag.naturalHeight > 0 && imgTag.src && imgTag.src !== window.location.href) {
                        handleImageLoad(imgTag);
                    }
                } else {
                    cardElement.style.display = 'none';
                }
            }
            if (!useDefaultTransitions) {
                requestAnimationFrame(() => {
                    cardElements.forEach(card => card.style.transition = '');
                });
            }
        }

        function animateCardRotation(newOrder) {
            if (isAnimating) return;
            isAnimating = true;

             const areaWidth = imageDisplayArea.clientWidth;
            const areaHeight = imageDisplayArea.clientHeight;

            const newFrontImageOriginalIndex = newOrder[0];
            const newFrontImageData = imagesData.find(img => img.index === newFrontImageOriginalIndex);
            const aspectRatio = (newFrontImageData && newFrontImageData.width && newFrontImageData.height) ?
                                (newFrontImageData.width / newFrontImageData.height) : (3/4);

            let frontCardWidth, frontCardHeight;
            const areaAspectRatio = areaWidth / areaHeight;

            if (aspectRatio > areaAspectRatio) {
                frontCardWidth = areaWidth * 0.9;
                frontCardHeight = frontCardWidth / aspectRatio;
                if (frontCardHeight > areaHeight * 0.9) {
                     frontCardHeight = areaHeight * 0.9;
                     frontCardWidth = frontCardHeight * aspectRatio;
                }
            } else {
                frontCardHeight = areaHeight * 0.9;
                frontCardWidth = frontCardHeight * aspectRatio;
                if (frontCardWidth > areaWidth * 0.9) {
                    frontCardWidth = areaWidth * 0.9;
                    frontCardHeight = frontCardWidth / aspectRatio;
                }
            }
             frontCardWidth = Math.max(150, frontCardWidth);
             frontCardHeight = Math.max(150 / aspectRatio, frontCardHeight);


            const backCardScale = 0.85;
            const backCardWidth = frontCardWidth * backCardScale;
            const backCardHeight = frontCardHeight * backCardScale;
            const backCardOpacity = 0.9;

            const xOffset = frontCardWidth * 0.40;
            const zOffset = -Math.min(areaWidth * 0.08, frontCardWidth * 0.15);
            const rotationAngle = 30;

            const positions = [
                { transform: `translate3d(0, 0, ${areaWidth * 0.05}px) scale(1) translateZ(0)`, zIndex: 3, opacity: 1, width: frontCardWidth, height: frontCardHeight, isFront: true },
                { transform: `translate3d(-${xOffset}px, 0, ${zOffset}px) rotateY(${rotationAngle}deg) scale(${backCardScale}) translateZ(0)`, zIndex: 2, opacity: backCardOpacity, width: backCardWidth, height: backCardHeight, isFront: false },
                { transform: `translate3d(${xOffset}px, 0, ${zOffset}px) rotateY(-${rotationAngle}deg) scale(${backCardScale}) translateZ(0)`, zIndex: 1, opacity: backCardOpacity, width: backCardWidth, height: backCardHeight, isFront: false }
            ];

            const cardElementToNewVisualSlotMap = new Map();
            cardElements.forEach(card => {
                const currentOriginalImageIdx = parseInt(card.dataset.imageDataOriginalIndex, 10);
                const newVisualSlotForThisImage = newOrder.indexOf(currentOriginalImageIdx);
                cardElementToNewVisualSlotMap.set(card, newVisualSlotForThisImage);
            });

            cardElements.forEach((card) => {
                const newVisualSlot = cardElementToNewVisualSlotMap.get(card);
                 if (newVisualSlot === undefined || newVisualSlot < 0) return;

                const finalStyle = positions[newVisualSlot];

                 card.style.transition = "transform 0.6s cubic-bezier(0.25, 0.8, 0.25, 1), opacity 0.5s ease-in-out, width 0.6s cubic-bezier(0.25, 0.8, 0.25, 1), height 0.6s cubic-bezier(0.25, 0.8, 0.25, 1)";
                 card.style.width = `${finalStyle.width}px`;
                 card.style.height = `${finalStyle.height}px`;
                 card.style.transform = finalStyle.transform;
                 card.style.zIndex = finalStyle.zIndex;
                 card.style.opacity = finalStyle.opacity;
                 card.classList.toggle('is-front', finalStyle.isFront);

                 card.dataset.cardSlotIndex = newVisualSlot;
             });

             currentCardOrder = [...newOrder];

             setTimeout(() => {
                 isAnimating = false;
                 cardElements.forEach(card => card.style.transition = '');
                 updateCardStackView(false);
             }, 600);
         }


        function handleImageLoad(imgElement) {
            const container = imgElement.closest('.image-container');
            if (!container) return;
            const loader = container.querySelector('.loader');
            const dataIndex = parseInt(imgElement.dataset.index, 10);

            if (loader) loader.classList.add('hidden');
            container.querySelectorAll('.error-display, .retry-button').forEach(el => el.remove());

            imgElement.classList.remove('error-state');
            imgElement.classList.add('loaded');

            const dataEntry = imagesData.find(d => d.index === dataIndex);
            if (dataEntry) {
                dataEntry.error = false;
                if (imgElement.src !== dataEntry.src) {
                    dataEntry.src = imgElement.src;
                }
            } else {
                const { width: currentFallbackWidth = 1024, height: currentFallbackHeight = 1024 } = getSelectedDimensions();
                findOrUpdateImageData(dataIndex, {
                    src: imgElement.src, error: false, index: dataIndex, prompt: currentPrompt || "Unknown",
                    seed: parseInt(imgElement.src.match(/seed=(\d+)/)?.[1] || Math.floor(Math.random() * 100000).toString(), 10),
                    model: imgElement.src.match(/model=([^&]+)/)?.[1] || modelSelect.value,
                    width: parseInt(imgElement.src.match(/width=(\d+)/)?.[1] || currentFallbackWidth.toString(), 10),
                    height: parseInt(imgElement.src.match(/height=(\d+)/)?.[1] || currentFallbackHeight.toString(), 10),
                    enhance: imgElement.src.includes('enhance=true')
                });
            }
        }

        function handleImageError(imgElement) {
            const container = imgElement.closest('.image-container');
            if (!container) return;
            const loader = container.querySelector('.loader');
            const dataIndex = parseInt(imgElement.dataset.index, 10);

            if (loader) loader.classList.add('hidden');
            container.querySelectorAll('.error-display, .retry-button').forEach(el => el.remove());

            const errorMsg = document.createElement('div');
            errorMsg.textContent = '加载错误';
            errorMsg.className = 'error-display';
            container.appendChild(errorMsg);

            const retryBtn = document.createElement('button');
            retryBtn.textContent = '重试';
            retryBtn.className = 'retry-button';
            retryBtn.dataset.index = dataIndex;
            container.appendChild(retryBtn);

            imgElement.classList.remove('loaded');
            imgElement.classList.add('error-state');

            const dataEntry = imagesData.find(d => d.index === dataIndex);
            if (dataEntry) {
                dataEntry.error = true;
            } else {
                findOrUpdateImageData(dataIndex, { src: imgElement.src, error: true, index: dataIndex, prompt: "未知 (初始加载错误)" });
            }
        }

        function retryImage(originalImageIndex) {
            const imageData = imagesData.find(item => item.index === originalImageIndex);
            const container = cardElements.find(card => parseInt(card.dataset.imageDataOriginalIndex) === originalImageIndex);


            if (!imageData || !container) {
                console.error("Cannot retry: imageData or container not found for index", originalImageIndex);
                return;
            }
             if (!imageData.prompt || !imageData.width || !imageData.height || imageData.seed === undefined || !imageData.model) {
                alert("无法重试：图像数据不完整。");
                return;
            }

            const imgElement = container.querySelector('img');
            const loader = container.querySelector('.loader');

            container.querySelectorAll('.error-display, .retry-button').forEach(el => el.remove());
            if (loader) loader.classList.remove('hidden');
            imgElement.classList.remove('error-state', 'loaded');
            imgElement.removeAttribute('src');

            const newImageUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(imageData.prompt)}?width=${imageData.width}&height=${imageData.height}&seed=${imageData.seed}&model=${imageData.model}${imageData.enhance ? '&enhance=true' : ''}${NOLOGO ? '&nologo=true' : ''}&safe=false`;

            imageData.error = null;
            imageData.src = newImageUrl;

            imgElement.src = newImageUrl;
        }


        async function generateImages() {
            if (sendButton.disabled) return;

            currentPrompt = promptInput.value.trim();
            if (!currentPrompt) {
                alert("请输入提示词！");
                promptInput.focus();
                return;
            }

            const { width, height, error: dimError } = getSelectedDimensions();
            if (dimError) {
                return;
            }

            const selectedModel = modelSelect.value;
            const enhance = enhanceCheckbox.checked;

            sendButton.disabled = true;
            sendButton.textContent = "生成中...";

            imagesData = [];
            currentCardOrder = Array.from({ length: NUM_IMAGES }, (_, i) => i);

            cardElements.forEach((card, i) => {
                card.dataset.cardSlotIndex = i;
                card.querySelector('.loader').classList.remove('hidden');
                card.querySelector('img').classList.remove('loaded', 'error-state');
                card.querySelector('img').src = '';
                card.querySelectorAll('.error-display, .retry-button').forEach(el => el.remove());
            });

            let seeds = Array.from({ length: NUM_IMAGES }, () => Math.floor(Math.random() * 100000));

            for (let i = 0; i < NUM_IMAGES; i++) {
                const currentSeed = seeds[i];
                const imageUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(currentPrompt)}?width=${width}&height=${height}&seed=${currentSeed}&model=${selectedModel}${enhance ? '&enhance=true' : ''}${NOLOGO ? '&nologo=true' : ''}&safe=false`;

                const newImageData = {
                    src: imageUrl,
                    index: i,
                    error: null,
                    prompt: currentPrompt, width: width, height: height,
                    seed: currentSeed, model: selectedModel, enhance: enhance
                };
                findOrUpdateImageData(i, newImageData);
            }

            updateCardStackView(false);

            const loadingCheckInterval = setInterval(() => {
                const allSettled = imagesData.every(imgData => imgData.error !== null || (imgData.src && imgData.src !== '' && (imgData.error === false || imgData.error === true)));
                if (imagesData.length === NUM_IMAGES && allSettled) {
                     clearInterval(loadingCheckInterval);
                     if (sendButton.disabled) {
                         sendButton.disabled = false;
                         sendButton.textContent = "发送";
                     }
                 }
            }, 500);

            setTimeout(() => {
                 if (sendButton.disabled) {
                     clearInterval(loadingCheckInterval);
                     sendButton.disabled = false;
                     sendButton.textContent = "发送";
                     imagesData.forEach(imgData => {
                        if (imgData.error === null) {
                            imgData.error = true;
                            const cardWithThisData = cardElements.find(c => parseInt(c.dataset.imageDataOriginalIndex) === imgData.index);
                            if (cardWithThisData) {
                                handleImageError(cardWithThisData.querySelector('img'));
                            }
                        }
                     });
                 }
            }, 20000);
        }

        function showImage(originalIndexToShow) {
            const imageData = imagesData.find(img => img.index === originalIndexToShow);
            if (!imageData) return;

            const modalArrayIndex = imagesData.findIndex(img => img.index === originalIndexToShow);
            if (modalArrayIndex === -1) return;
            currentModalIndex = modalArrayIndex;

            modalImg.src = imageData.src;
            modalImg.style.display = 'block';
            if (imageData.error) {
                modalImg.style.border = '3px dashed var(--danger-color)';
                modalImg.alt = `预览 (加载错误) - 提示词: ${imageData.prompt}`;
            } else {
                modalImg.style.border = 'none';
                modalImg.alt = `预览 - 提示词: ${imageData.prompt}, 种子: ${imageData.seed}`;
            }
            modal.classList.add('active');
        }

        function showContextMenu(event, targetOriginalIndex) {
            event.preventDefault();
            contextMenu.style.display = 'block';
            const menuWidth = contextMenu.offsetWidth;
            const menuHeight = contextMenu.offsetHeight;
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            let left = event.clientX;
            let top = event.clientY;
            if (left + menuWidth > windowWidth - 10) left = windowWidth - menuWidth - 10;
            if (top + menuHeight > windowHeight - 10) top = windowHeight - menuHeight - 10;
            if (left < 10) left = 10;
            if (top < 10) top = 10;
            contextMenu.style.left = `${left}px`;
            contextMenu.style.top = `${top}px`;
            contextMenu.dataset.targetIndex = targetOriginalIndex;
        }

        function hideContextMenu() {
            if (contextMenu.style.display === 'block') {
                contextMenu.style.display = 'none';
                delete contextMenu.dataset.targetIndex;
            }
        }
        async function copyImage(imageData) {
            hideContextMenu();
            if (!imageData || !imageData.src) {
                alert("无法复制：图像数据或源链接缺失。");
                return;
            }
            if (imageData.error){
                alert("无法复制加载失败的图像。");
                return;
            }

            try {
                const response = await fetch(imageData.src);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const blob = await response.blob();

                if (typeof window.api === 'object' && typeof window.api.copyImage === 'function') {
                    const arrayBuffer = await blob.arrayBuffer();
                    const uint8Array = new Uint8Array(arrayBuffer);
                    const success = window.api.copyImage(uint8Array);
                    if (!success) {
                        alert("使用应用程序API复制图像失败。");
                    }
                } else if (navigator.clipboard && navigator.clipboard.write) {
                     if (!blob.type.startsWith('image/')) {
                        throw new Error('Fetched data is not a recognized image type for clipboard.');
                    }
                    await navigator.clipboard.write([
                        new ClipboardItem({ [blob.type]: blob })
                    ]);
                } else {
                    alert("复制到剪贴板功能在此环境中不可用。\n请尝试下载图像。");
                }
            } catch (err) {
                alert(`无法复制图像。\n错误: ${err.message}\n(这可能是由于浏览器安全限制、缺少HTTPS协议或网络问题所致。)`);
            }
        }
        async function downloadImage(imageData) {
            hideContextMenu();
            if (!imageData || !imageData.src || imageData.seed === undefined || imageData.seed === null) {
                alert("无法下载：图像数据、源链接或种子值缺失。");
                return;
            }
             if (imageData.error){
                alert("无法下载加载失败的图像。");
                return;
            }
            const seed = imageData.seed;
            let extensionMatch = imageData.src.match(/\.([a-zA-Z0-9]+)(?:[?#]|$)/);
            let extension = extensionMatch ? extensionMatch[1].toLowerCase() : 'png';
            if (!['jpg', 'jpeg', 'png', 'gif', 'webp'].includes(extension)) {
                extension = 'png';
            }
            const filename = `AI图像_${seed}_${imageData.width}x${imageData.height}.${extension}`;
            try {
                const response = await fetch(imageData.src, { mode: 'cors' });
                if (!response.ok) throw new Error(`HTTP error! Status: ${response.status} ${response.statusText}`);
                const blob = await response.blob();
                const blobUrl = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = blobUrl;
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                setTimeout(() => URL.revokeObjectURL(blobUrl), 100);
            } catch (error) {
                let alertMessage = `无法下载图像。\n错误: ${error.message}`;
                if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError') || error.message.includes('cors')) {
                    alertMessage += "\n(这可能是网络或CORS跨域问题。请尝试在新标签页中打开图像并保存。)";
                }
                alert(alertMessage);
            }
        }

        function attachModalListeners() {
            if (!modal || modal.dataset.listenersAttached === 'true') return;
            closeBtn.addEventListener('click', () => modal.classList.remove('active'));

            prevBtn.addEventListener('click', (event) => {
                event.stopPropagation(); if (imagesData.length === 0) return;
                const navigableImages = imagesData;
                if (navigableImages.length === 0) return;

                let currentNavigableIndex = navigableImages.findIndex(img => img.index === imagesData[currentModalIndex].index);
                if (currentNavigableIndex === -1) currentNavigableIndex = 0;

                const newNavigableIndex = (currentNavigableIndex - 1 + navigableImages.length) % navigableImages.length;
                showImage(navigableImages[newNavigableIndex].index);
            });
            nextBtn.addEventListener('click', (event) => {
                event.stopPropagation(); if (imagesData.length === 0) return;
                const navigableImages = imagesData;
                if (navigableImages.length === 0) return;

                let currentNavigableIndex = navigableImages.findIndex(img => img.index === imagesData[currentModalIndex].index);
                if (currentNavigableIndex === -1) currentNavigableIndex = 0;

                const newNavigableIndex = (currentNavigableIndex + 1) % navigableImages.length;
                showImage(navigableImages[newNavigableIndex].index);
            });

            modal.addEventListener('click', (e) => { if (e.target === modal) modal.classList.remove('active'); });
            modal.dataset.listenersAttached = 'true';
        }

        function attachGlobalListeners() {
            initializeCardElements();

            sendButton.addEventListener('click', generateImages);
            promptInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !sendButton.disabled) {
                    generateImages();
                }
            });

            dimensionSelect.addEventListener('change', () => {
                if (dimensionSelect.value === 'custom') {
                    customDimensionsWrapper.style.display = 'block';
                    if (!customWidthInput.value) customWidthInput.value = "512";
                    if (!customHeightInput.value) customHeightInput.value = "768";
                    customWidthInput.focus();
                } else {
                    customDimensionsWrapper.style.display = 'none';
                }
                adjustBodyPadding();
            });
            customWidthInput.addEventListener('change', adjustBodyPadding);
            customHeightInput.addEventListener('change', adjustBodyPadding);


            imageDisplayArea.addEventListener('click', (event) => {
                const retryButton = event.target.closest('.retry-button');
                if (retryButton) {
                    event.stopPropagation();
                    const indexToRetry = parseInt(retryButton.dataset.index, 10);
                    retryImage(indexToRetry);
                }
            });


            imageDisplayArea.addEventListener('contextmenu', (event) => {
                const container = event.target.closest('.image-container.is-front');
                if (container) {
                    const targetOriginalIndex = parseInt(container.dataset.imageDataOriginalIndex, 10);
                    const imgData = imagesData.find(d => d.index === targetOriginalIndex);
                    if (imgData && !imgData.error && container.querySelector('img.loaded')) {
                        showContextMenu(event, targetOriginalIndex);
                    } else {
                        event.preventDefault();
                    }
                } else {
                    hideContextMenu();
                }
            });

            contextMenu.addEventListener('click', (event) => {
                const item = event.target.closest('.context-menu-item');
                if (item) {
                    const action = item.dataset.action;
                    const targetOriginalIndex = parseInt(contextMenu.dataset.targetIndex, 10);
                    const imageData = imagesData.find(d => d.index === targetOriginalIndex);
                    if (imageData && !imageData.error) {
                        if (action === 'download') {
                            downloadImage(imageData);
                        } else if (action === 'copy') {
                            copyImage(imageData);
                        }
                    }
                    hideContextMenu();
                }
            });

            document.addEventListener('click', (event) => {
                if (!contextMenu.contains(event.target) && !event.target.closest('.image-container.is-front img.loaded')) {
                     hideContextMenu();
                }
            });
            window.addEventListener('scroll', hideContextMenu, true);

            document.addEventListener('keydown', (e) => {
                if (modal.classList.contains('active')) {
                    switch (e.key) {
                        case 'ArrowLeft': prevBtn.click(); break;
                        case 'ArrowRight': nextBtn.click(); break;
                        case 'Escape': closeBtn.click(); break;
                    }
                } else if (e.key === 'Escape') {
                    hideContextMenu();
                }
            });

            window.addEventListener('load', adjustBodyPadding);
            window.addEventListener('resize', adjustBodyPadding);

            if (dimensionSelect.value === 'custom') {
                customDimensionsWrapper.style.display = 'block';
            }
            adjustBodyPadding();
        }

        attachGlobalListeners();
        attachModalListeners();
    </script>
</body>

</html>
